group protocob-group : cobol-group;

/**
 * Template to convert a COBOL data item to a protocol buffer parser.
 */
toProtocobParser(protoCobolDataItem) ::= <<
       IDENTIFICATION DIVISION.
       PROGRAM-ID. $protoCobolDataItem.parserProgramName$.
      *****************************************************************
      * OVERVIEW                                                      *
      * --------                                                      *
      * Subprogram that parses a protobuf byte stream and populates   *
      * a cobol structure.                                            *
      *                                                               *
      * This is generated code produced by protobuf-cobol.            *
      * It uses the PB4CBLIB protobuf-cobol library.                  *
      *                                                               *
      * Limits:                                                       *
      *    256 fields per message                                     *
      *    16777215 message byte length                               *
      *                                                               *
      *****************************************************************

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER. IBM-390 WITH DEBUGGING MODE.
       DATA DIVISION.
      *****************************************************************
      *        W O R K I N G    S T O R A G E    S E C T I O N        *
      *****************************************************************
       WORKING-STORAGE SECTION.

      *    // z/OS code page
       77  ZOS-CODEPAGE              PIC 9(4) COMP VALUE 1047.

      *    // Protobuf field key and type
       01  W-P-KEYTYPE.
           05  W-P-KEY               PIC 9(8) COMP-5.
           05  W-P-TYPE              PIC 9(4) COMP-5.
               88 VARINT             VALUE 0.
               88 FIXED-64           VALUE 1.
               88 LENGTH-DELIMITED   VALUE 2.
               88 FIXED-32           VALUE 5.
               88 VALID-WIRE-TYPE    VALUE 0, 1, 2, 5.

      *    // Tracks the current location in protobuf byte stream
       01  W-I                       PIC 9(8) COMP-5.

      *    // A pointer to the current protobuf byte stream location
       01  W-STREAM                  POINTER.

      *    // A double word binary to hold unsigned long integers
       01  W-Z-UINT64                PIC 9(18) COMP-5.

      *    // A single word binary to hold unsigned integers
       01  W-Z-UINT32                PIC 9(8) COMP-5.

      *    // A double word binary to hold signed long integers
       01  W-Z-INT64                 PIC S9(18) COMP-5.

      *    // A single word binary to hold signed integers
       01  W-Z-INT32                 PIC S9(8) COMP-5.

      *    // A simple floating point numeric
       01  W-Z-COMP-1                COMP-1.

      *    // A double floating point numeric
       01  W-Z-COMP-2                COMP-2.

      *    // Library calls return how many stream bytes were consumed
       01  W-BYTES-USED              PIC 9(8) COMP-5.


$if(protoCobolDataItem.hasSubStructures)$
      *    // Sub-messages maximum offset from input start
$protoCobolDataItem.subStructuresCobolName:listSubMessageLength(); separator="\n"$$endif$

$if(protoCobolDataItem.hasCobolCounterNames)$
      *    // Array indexes
$protoCobolDataItem.allCobolCounterNames:declareCobolCounter(); separator="\n"$$endif$

$if(protoCobolDataItem.hasAlphanumItems)$
      *    // Conversion buffer for Strings
       01  W-UTF16-BUFFER            PIC N($protoCobolDataItem.maxStringSize$).$endif$

      *****************************************************************
      *        L I N K A G E    S E C T I O N                         *
      *****************************************************************
       LINKAGE SECTION.

      *    // The protobuf input byte stream
       01  PROTOBUF-BYTES            PIC X(16777215).

      *    // The protobuf input byte stream length
       01  PROTOBUF-BYTES-LEN        PIC 9(8) COMP-5.

      *    // The output COBOL structure
$protoCobolDataItem.copybook$

      *    // A protobuf variable integer
       01  P-VARINT                  PIC X(10).

      *    // A protobuf float (IEEE 754)
       01  P-FLOAT                   PIC X(4).

      *    // A protobuf double (IEEE 754)
       01  P-DOUBLE                  PIC X(8).

      *****************************************************************
      *    P R O C E D U R E  D I V I S I O N   S E C T I O N         *
      *****************************************************************
       PROCEDURE DIVISION USING
               PROTOBUF-BYTES,
               PROTOBUF-BYTES-LEN,
$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$protoCobolDataItem.cobolName$.
      *    // Parse the root protobuf message
$protoCobolDataItem.directChildrenCobolCounterNames:initCobolCounterCol12(); separator="\n"$
           MOVE 1 TO W-I.
           PERFORM PARSE-$protoCobolDataItem.cobolName$ THRU
               END-PARSE-$protoCobolDataItem.cobolName$
                   UNTIL W-I > PROTOBUF-BYTES-LEN.
           GOBACK.

$parseDataItem(protoCobolDataItem)$

      * ---------------------------------------------------------------
      * Get a field key (identifier) and type from the stream.
      *
      * Field and Type are both encoded in a single variable integer.
      *
      * Field type is 3 lower bits of header varint, higher bits are
      * the field key (identifier)
      * ---------------------------------------------------------------
       GET-P-KEYTYPE.
           PERFORM P-VARINT-TO-Z-UINT64 THRU END-P-VARINT-TO-Z-UINT64.
           DIVIDE W-Z-UINT64 BY 8 GIVING W-P-KEY REMAINDER W-P-TYPE.
       END-GET-P-KEYTYPE. EXIT.

      * ---------------------------------------------------------------
      * Get a variable integer from the stream as unsigned double word
      * binary.
      * ---------------------------------------------------------------
       P-VARINT-TO-Z-UINT64.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBVI2U64' USING P-VARINT W-Z-UINT64 W-BYTES-USED.
       END-P-VARINT-TO-Z-UINT64. EXIT.

      * ---------------------------------------------------------------
      * Get a variable integer from the stream as unsigned single word
      * binary.
      * ---------------------------------------------------------------
       P-VARINT-TO-Z-UINT32.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBVI2U32' USING P-VARINT W-Z-UINT32 W-BYTES-USED.
       END-P-VARINT-TO-Z-UINT32. EXIT.

      * ---------------------------------------------------------------
      * Get a variable integer from the stream as signed double word
      * binary.
      * ---------------------------------------------------------------
       P-VARINT-TO-Z-INT64.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBVI2S64' USING P-VARINT W-Z-INT64 W-BYTES-USED.
       END-P-VARINT-TO-Z-INT64. EXIT.

      * ---------------------------------------------------------------
      * Get a variable integer from the stream as signed single word
      * binary.
      * ---------------------------------------------------------------
       P-VARINT-TO-Z-INT32.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBVI2S32' USING P-VARINT W-Z-INT32 W-BYTES-USED.
       END-P-VARINT-TO-Z-INT32. EXIT.

      * ---------------------------------------------------------------
      * Get a IEEE float from the stream as a COMP-1
      * ---------------------------------------------------------------
       P-FLOAT-TO-Z-COMP-1.
           SET ADDRESS OF P-FLOAT TO W-STREAM.
           CALL 'PB2ZFLOA' USING P-FLOAT W-Z-COMP-1 W-BYTES-USED.
       END-P-FLOAT-TO-Z-COMP-1. EXIT.

      * ---------------------------------------------------------------
      * Get a IEEE double from the stream as a COMP-2
      * ---------------------------------------------------------------
       P-DOUBLE-TO-Z-COMP-2.
           SET ADDRESS OF P-DOUBLE TO W-STREAM.
           CALL 'PB2ZDBLE' USING P-DOUBLE W-Z-COMP-2 W-BYTES-USED.
       END-P-DOUBLE-TO-Z-COMP-2. EXIT.

       END PROGRAM $protoCobolDataItem.parserProgramName$.
>>

/**
 * Template to convert a COBOL data item to a protocol buffer writer.
 */
toProtocobWriter(protoCobolDataItem) ::= <<
       IDENTIFICATION DIVISION.
       PROGRAM-ID. $protoCobolDataItem.writerProgramName$.
      *****************************************************************
      * OVERVIEW                                                      *
      * --------                                                      *
      * Subprogram that writes a protobuf byte stream from  a cobol   *
      * structure content.                                            *
      *                                                               *
      * This is generated code produced by protobuf-cobol.            *
      * It uses the PB4CBLIB protobuf-cobol library.                  *
      *                                                               *
      * Limits:                                                       *
      *    256 fields per message                                     *
      *    16777215 message byte length                               *
      *                                                               *
      *****************************************************************

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SOURCE-COMPUTER. IBM-390 WITH DEBUGGING MODE.
       DATA DIVISION.
      *****************************************************************
      *        W O R K I N G    S T O R A G E    S E C T I O N        *
      *****************************************************************
       WORKING-STORAGE SECTION.

      *    // z/OS code page
       77  ZOS-CODEPAGE             PIC 9(4) COMP VALUE 1047.

      *    // Protobuf field key and type
       01  W-P-KEYTYPE.
           05  W-P-KEY               PIC 9(8) COMP-5.
           05  W-P-TYPE              PIC 9(4) COMP-5.
               88 VARINT             VALUE 0.
               88 FIXED-64           VALUE 1.
               88 LENGTH-DELIMITED   VALUE 2.
               88 FIXED-32           VALUE 5.
               88 VALID-WIRE-TYPE    VALUE 0, 1, 2, 5.

      *    // Tracks the current location in protobuf byte stream
       01  W-I                       PIC 9(8) COMP-5.

      *    // A pointer to the current protobuf byte stream location
       01  W-STREAM                  POINTER.

      *    // A double word binary to hold unsigned long integers
       01  W-Z-UINT64                PIC 9(18) COMP-5.

      *    // A single word binary to hold unsigned integers
       01  W-Z-UINT32                PIC 9(8) COMP-5.

      *    // A double word binary to hold signed long integers
       01  W-Z-INT64                 PIC S9(18) COMP-5.

      *    // A single word binary to hold signed integers
       01  W-Z-INT32                 PIC S9(8) COMP-5.

      *    // A simple floating point numeric
       01  W-Z-COMP-1                COMP-1.

      *    // A double floating point numeric
       01  W-Z-COMP-2                COMP-2.

      *    // Library calls return how many stream bytes were consumed
       01  W-BYTES-USED              PIC 9(8) COMP-5.

$if(protoCobolDataItem.hasSubStructures)$
      *    // Sub-messages length
$protoCobolDataItem.subStructuresCobolName:listSubMessageLength(); separator="\n"$$endif$

$if(protoCobolDataItem.hasCobolCounterNames)$
      *    // Array indexes
$protoCobolDataItem.allCobolCounterNames:declareCobolCounter(); separator="\n"$$endif$

      *    // Conversion buffer for Strings
       01  W-UTF16-BUFFER            PIC N(32).

      *    // Temporary storage for variable integers
       01  W-P-VARINT                PIC X(10).

      *    // Counters
       01  W-J                       PIC 9(8) COMP-5.

      *****************************************************************
      *        L I N K A G E    S E C T I O N                         *
      *****************************************************************
       LINKAGE SECTION.

      *    // The protobuf input byte stream
       01  PROTOBUF-BYTES            PIC X(16777215).

      *    // The protobuf input byte stream length
       01  PROTOBUF-BYTES-LEN        PIC 9(8) COMP-5.

      *    // The input COBOL structure
$protoCobolDataItem.copybook$

      *    // A protobuf variable integer
       01  P-VARINT                  PIC X(10).

      *    // A protobuf float (IEEE 754)
       01  P-FLOAT                   PIC X(4).

      *    // A protobuf double (IEEE 754)
       01  P-DOUBLE                  PIC X(8).

      *****************************************************************
      *    P R O C E D U R E  D I V I S I O N   S E C T I O N         *
      *****************************************************************
       PROCEDURE DIVISION USING
$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$\ $$protoCobolDataItem.cobolName$,
               PROTOBUF-BYTES,
               PROTOBUF-BYTES-LEN.
      *    // Write the root protobuf message
$protoCobolDataItem.directChildrenCobolCounterNames:initCobolCounterCol12(); separator="\n"$
           MOVE 1 TO W-I.
           PERFORM WRITE-$protoCobolDataItem.cobolName$ THRU
               END-WRITE-$protoCobolDataItem.cobolName$.
           COMPUTE PROTOBUF-BYTES-LEN = W-I - 1.
           GOBACK.

$writeDataItem(protoCobolDataItem)$

      * ---------------------------------------------------------------
      * Write a field key (identifier) and type to the stream.
      *
      * Field and Type are both encoded in a single variable integer.
      *
      * Field type is 3 lower bits of header varint, higher bits are
      * the field key (identifier)
      * ---------------------------------------------------------------
       PUT-P-KEYTYPE.
           COMPUTE W-Z-UINT64 = W-P-TYPE + (8 * W-P-KEY).
           PERFORM Z-UINT64-TO-P-VARINT THRU END-Z-UINT64-TO-P-VARINT.
       END-PUT-P-KEYTYPE. EXIT.

      * ---------------------------------------------------------------
      * Put an unsigned double word binary as a variable integer to the
      * output stream.
      * ---------------------------------------------------------------
       Z-UINT64-TO-P-VARINT.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBU642VI' USING W-Z-UINT64 P-VARINT W-BYTES-USED.
       END-Z-UINT64-TO-P-VARINT. EXIT.

      * ---------------------------------------------------------------
      * Put an unsigned single word binary as a variable integer to the
      * output stream.
      * ---------------------------------------------------------------
       Z-UINT32-TO-P-VARINT.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBU322VI' USING W-Z-UINT32 P-VARINT W-BYTES-USED.
       END-Z-UINT32-TO-P-VARINT. EXIT.

      * ---------------------------------------------------------------
      * Put a signed double word binary as a variable integer to the
      * output stream.
      * ---------------------------------------------------------------
       Z-INT64-TO-P-VARINT.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBS642VI' USING W-Z-INT64 P-VARINT W-BYTES-USED.
       END-Z-INT64-TO-P-VARINT. EXIT.

      * ---------------------------------------------------------------
      * Put a signed single word binary as a variable integer to the
      * output stream.
      * ---------------------------------------------------------------
       Z-INT32-TO-P-VARINT.
           SET ADDRESS OF P-VARINT TO W-STREAM.
           CALL 'PBS322VI' USING W-Z-INT32 P-VARINT W-BYTES-USED.
       END-Z-INT32-TO-P-VARINT. EXIT.

      * ---------------------------------------------------------------
      * Put a COMP-1 as a IEEE float to the output stream.
      * ---------------------------------------------------------------
       Z-COMP-1-TO-P-FLOAT.
           SET ADDRESS OF P-FLOAT TO W-STREAM.
           CALL 'PB2PFLOA' USING W-Z-COMP-1 P-FLOAT W-BYTES-USED.
       END-Z-COMP-1-TO-P-FLOAT. EXIT.

      * ---------------------------------------------------------------
      * Put a COMP-2 as a IEEE double to the output stream.
      * ---------------------------------------------------------------
       Z-COMP-2-TO-P-DOUBLE.
           SET ADDRESS OF P-DOUBLE TO W-STREAM.
           CALL 'PB2PDBLE' USING W-Z-COMP-2 P-DOUBLE W-BYTES-USED.
       END-Z-COMP-2-TO-P-DOUBLE. EXIT.

       END PROGRAM $protoCobolDataItem.writerProgramName$.
>>

listSubMessageLength() ::= <<
       01  W-$it$-L     PIC 9(8) COMP-5.
>>

declareCobolCounter() ::= <<
       01  $it$     PIC 9(8) COMP-5.
>>

initCobolCounterCol12() ::= <<
           MOVE ZERO TO $it$.
>>

initCobolCounterCol18() ::= <<
                 MOVE ZERO TO $it$
>>

parseDataItem(protoCobolDataItem) ::= <<
$if(protoCobolDataItem.structure)$
      * ---------------------------------------------------------------
      * Parse the $protoCobolDataItem.cobolName$ message field
      * ---------------------------------------------------------------
       PARSE-$protoCobolDataItem.cobolName$.
      D    DISPLAY 'PARSE-$protoCobolDataItem.cobolName$ OFFSET=' W-I.

           SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:).
           PERFORM GET-P-KEYTYPE THRU END-GET-P-KEYTYPE.
           ADD W-BYTES-USED TO W-I.

           SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:).
           EVALUATE W-P-KEY
$protoCobolDataItem.children:parseChild(protoCobolDataItem=it); separator="\n"$
           END-EVALUATE.
       END-PARSE-$protoCobolDataItem.cobolName$. EXIT.

$protoCobolDataItem.children:parseDataItem(protoCobolDataItem=it)$$endif$
>>

writeDataItem(protoCobolDataItem) ::= <<
$if(protoCobolDataItem.structure)$
      * ---------------------------------------------------------------
      * Write the $protoCobolDataItem.cobolName$ message field
      * ---------------------------------------------------------------
       WRITE-$protoCobolDataItem.cobolName$.
      D    DISPLAY 'WRITE-$protoCobolDataItem.cobolName$ OFFSET=' W-I.
$protoCobolDataItem.children:writeChild(protoCobolDataItem=it); separator="\n"$
       END-WRITE-$protoCobolDataItem.cobolName$. EXIT.

$protoCobolDataItem.children:writeDataItem(protoCobolDataItem=it)$$endif$
$protoCobolDataItem.children:writeCalcSizeDataItem(protoCobolDataItem=it)$$endif$
>>

parseChild(protoCobolDataItem) ::= <<
               WHEN $i$
$incrementCounter(protoCobolDataItem)$
$protoCobolDataItem.directChildrenCobolCounterNames:initCobolCounterCol18(); separator="\n"$
$if(protoCobolDataItem.mappedToBool)$
$pBoolToZUInt32(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToString)$
$pStringToZAlphanum(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToEnum)$
$pEnumToZUInt32(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToInt32)$
$pVarintToZInt32(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToInt64)$
$pVarintToZInt64(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToUint32)$
$pVarintToZUInt32(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToUint64)$
$pVarintToZUInt64(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToFloat)$
$pFloatToZComp1(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToDouble)$
$pDoubleToZComp2(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToMessage)$
$messageToGroup(protoCobolDataItem)$$endif$
>>

writeChild(protoCobolDataItem) ::= <<
           PERFORM $if(protoCobolDataItem.array)$VARYING $protoCobolDataItem.cobolCounterName$ FROM 1 BY 1
                   UNTIL $protoCobolDataItem.cobolCounterName$ > $if(protoCobolDataItem.hasDependingOn)$$protoCobolDataItem.dependingOn$$else$$protoCobolDataItem.maxOccurs$$endif$$endif$

               SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:)
               MOVE $i$ TO W-P-KEY
$if(protoCobolDataItem.mappedToString)$
$zAlphanumToPString(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToEnum)$
$zUInt32ToPEnum(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToInt32)$
$zInt32ToPVarint(protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToMessage)$
$groupToMessage(protoCobolDataItem)$$endif$

           END-PERFORM.
>>

writeCalcSizeDataItem(protoCobolDataItem) ::= <<
$if(protoCobolDataItem.structure)$
      * ---------------------------------------------------------------
      * Calculates the $protoCobolDataItem.cobolName$ message size
      * ---------------------------------------------------------------
       CALC-$protoCobolDataItem.cobolName$-SIZE.
      D    DISPLAY 'CALC-$protoCobolDataItem.cobolName$-SIZE OFFSET=' W-I.
           MOVE ZERO TO W-$protoCobolDataItem.cobolName$-L.

$protoCobolDataItem.children:writeCalcSizeChild(parent=protoCobolDataItem, protoCobolDataItem=it); separator="\n"$

      D    DISPLAY '$protoCobolDataItem.cobolName$ size=' W-$protoCobolDataItem.cobolName$-L.
       END-CALC-$protoCobolDataItem.cobolName$-SIZE. EXIT.

$endif$
>>

writeCalcSizeChild(parent, protoCobolDataItem) ::= <<
           PERFORM $if(protoCobolDataItem.array)$VARYING $protoCobolDataItem.cobolCounterName$ FROM 1 BY 1
                   UNTIL $protoCobolDataItem.cobolCounterName$ > $if(protoCobolDataItem.hasDependingOn)$$protoCobolDataItem.dependingOn$$else$$protoCobolDataItem.maxOccurs$$endif$$endif$

               ADD 1 TO W-$parent.cobolName$-L
$if(protoCobolDataItem.mappedToString)$
$calcSizeZAlphanumToPString(parent=parent, protoCobolDataItem=protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToEnum)$
$calcSizeZUInt32ToPEnum(parent=parent, protoCobolDataItem=protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToInt32)$
$calcSizeZInt32ToPVarint(parent=parent, protoCobolDataItem=protoCobolDataItem)$$elseif(protoCobolDataItem.mappedToMessage)$
$calcSizeGroupToMessage(parent=parent, protoCobolDataItem=protoCobolDataItem)$$endif$

           END-PERFORM.
>>

pBoolToZUInt32(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-UINT32 THRU
                     END-P-VARINT-TO-Z-UINT32
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-UINT32
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

pStringToZAlphanum(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-UINT32 THRU
                     END-P-VARINT-TO-Z-UINT32
                 ADD W-BYTES-USED TO W-I
                 MOVE FUNCTION NATIONAL-OF(
                    PROTOBUF-BYTES(W-I:W-Z-UINT32), 01208)
                    TO W-UTF16-BUFFER
                 MOVE FUNCTION DISPLAY-OF(W-UTF16-BUFFER, ZOS-CODEPAGE)
                    TO $protoCobolDataItem.indexedCobolName$
                 COMPUTE W-BYTES-USED = W-Z-UINT32
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

zAlphanumToPString(protoCobolDataItem) ::= <<
               SET LENGTH-DELIMITED TO TRUE
               PERFORM PUT-P-KEYTYPE THRU END-PUT-P-KEYTYPE
               ADD W-BYTES-USED TO W-I

               SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:)
               MOVE ZERO TO W-Z-UINT32
               PERFORM VARYING W-J FROM 1 BY 1 UNTIL W-J > 
                       LENGTH OF $protoCobolDataItem.indexedCobolName$
                   IF ($protoCobolDataItem.indexedCobolName$(W-J:1)
                       NOT = SPACE AND LOW-VALUE)
                       MOVE W-J TO W-Z-UINT32
                   END-IF
               END-PERFORM
               PERFORM Z-UINT32-TO-P-VARINT THRU
                   END-Z-UINT32-TO-P-VARINT
               ADD W-BYTES-USED TO W-I

               MOVE FUNCTION
                   NATIONAL-OF($protoCobolDataItem.indexedCobolName$,
                               ZOS-CODEPAGE) TO W-UTF16-BUFFER
               MOVE FUNCTION DISPLAY-OF(W-UTF16-BUFFER, 01208)
                   TO PROTOBUF-BYTES(W-I:W-Z-UINT32)
               COMPUTE W-BYTES-USED = W-Z-UINT32
$debugWrite(protoCobolDataItem)$
               ADD W-BYTES-USED TO W-I
>>

calcSizeZAlphanumToPString(parent, protoCobolDataItem) ::= <<
               SET W-STREAM TO ADDRESS OF W-P-VARINT
               MOVE ZERO TO W-Z-UINT32
               PERFORM VARYING W-J FROM 1 BY 1 UNTIL W-J >
                       LENGTH OF $protoCobolDataItem.indexedCobolName$
                   IF ($protoCobolDataItem.indexedCobolName$(W-J:1)
                       NOT = SPACE AND LOW-VALUE)
                       MOVE W-J TO W-Z-UINT32
                   END-IF
               END-PERFORM
               PERFORM Z-UINT32-TO-P-VARINT THRU
                   END-Z-UINT32-TO-P-VARINT
               ADD W-BYTES-USED TO W-$parent.cobolName$-L
               ADD W-Z-UINT32 TO W-$parent.cobolName$-L
>>

pEnumToZUInt32(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-UINT32 THRU
                     END-P-VARINT-TO-Z-UINT32
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-UINT32
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

zUInt32ToPEnum(protoCobolDataItem) ::= <<
               SET VARINT TO TRUE
               PERFORM PUT-P-KEYTYPE THRU END-PUT-P-KEYTYPE
               ADD W-BYTES-USED TO W-I
    
               SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:)
               COMPUTE W-Z-UINT32
                     = $protoCobolDataItem.indexedCobolName$
               PERFORM Z-UINT32-TO-P-VARINT THRU
                   END-Z-UINT32-TO-P-VARINT
$debugWrite(protoCobolDataItem)$
               ADD W-BYTES-USED TO W-I
>>

calcSizeZUInt32ToPEnum(parent, protoCobolDataItem) ::= <<
               SET W-STREAM TO ADDRESS OF W-P-VARINT
               COMPUTE W-Z-UINT32
                     = $protoCobolDataItem.indexedCobolName$
               PERFORM Z-UINT32-TO-P-VARINT THRU
                   END-Z-UINT32-TO-P-VARINT
               ADD W-BYTES-USED TO W-$parent.cobolName$-L
>>

pVarintToZInt32(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-INT32 THRU
                     END-P-VARINT-TO-Z-INT32
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-INT32
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

zInt32ToPVarint(protoCobolDataItem) ::= <<
               SET VARINT TO TRUE
               PERFORM PUT-P-KEYTYPE THRU END-PUT-P-KEYTYPE
               ADD W-BYTES-USED TO W-I
    
               SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:)
               COMPUTE W-Z-INT32
                     = $protoCobolDataItem.indexedCobolName$
               PERFORM Z-INT32-TO-P-VARINT THRU
                   END-Z-INT32-TO-P-VARINT
$debugWrite(protoCobolDataItem)$
               ADD W-BYTES-USED TO W-I
>>

calcSizeZInt32ToPVarint(parent, protoCobolDataItem) ::= <<
               SET W-STREAM TO ADDRESS OF W-P-VARINT
               COMPUTE W-Z-INT32
                     = $protoCobolDataItem.indexedCobolName$
               PERFORM Z-INT32-TO-P-VARINT THRU
                   END-Z-INT32-TO-P-VARINT
               ADD W-BYTES-USED TO W-$parent.cobolName$-L
>>

pVarintToZInt64(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-INT64 THRU
                     END-P-VARINT-TO-Z-INT64
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-INT64
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

pVarintToZUInt32(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-UINT32 THRU
                     END-P-VARINT-TO-Z-UINT32
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-UINT32
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

pVarintToZUInt64(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-UINT64 THRU
                     END-P-VARINT-TO-Z-UINT64
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-UINT64
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

pFloatToZComp1(protoCobolDataItem) ::= <<
                 PERFORM P-FLOAT-TO-Z-COMP-1 THRU
                     END-P-FLOAT-TO-Z-COMP-1
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-COMP-1
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

pDoubleToZComp2(protoCobolDataItem) ::= <<
                 PERFORM P-DOUBLE-TO-Z-COMP-2 THRU
                     END-P-DOUBLE-TO-Z-COMP-2
                 COMPUTE $protoCobolDataItem.indexedCobolName$
                       = W-Z-COMP-2
$debugParse(protoCobolDataItem)$
                 ADD W-BYTES-USED TO W-I
>>

messageToGroup(protoCobolDataItem) ::= <<
                 PERFORM P-VARINT-TO-Z-UINT32 THRU
                     END-P-VARINT-TO-Z-UINT32
                 ADD W-BYTES-USED TO W-I
                 COMPUTE W-$protoCobolDataItem.cobolName$-L = W-I + W-Z-UINT32 - 1
                 PERFORM PARSE-$protoCobolDataItem.cobolName$ THRU
                     END-PARSE-$protoCobolDataItem.cobolName$
                         UNTIL W-I > W-$protoCobolDataItem.cobolName$-L
>>

groupToMessage(protoCobolDataItem) ::= <<
               SET LENGTH-DELIMITED TO TRUE
               PERFORM PUT-P-KEYTYPE THRU END-PUT-P-KEYTYPE
               ADD W-BYTES-USED TO W-I
    
               PERFORM CALC-$protoCobolDataItem.cobolName$-SIZE THRU
                   END-CALC-$protoCobolDataItem.cobolName$-SIZE
               SET W-STREAM TO ADDRESS OF PROTOBUF-BYTES(W-I:)
               COMPUTE W-Z-UINT32 = W-$protoCobolDataItem.cobolName$-L
               PERFORM Z-UINT32-TO-P-VARINT THRU
                   END-Z-UINT32-TO-P-VARINT
               ADD W-BYTES-USED TO W-I

               PERFORM WRITE-$protoCobolDataItem.cobolName$ THRU
                   END-WRITE-$protoCobolDataItem.cobolName$

>>

calcSizeGroupToMessage(parent, protoCobolDataItem) ::= <<
               PERFORM CALC-$protoCobolDataItem.cobolName$-SIZE THRU
                   END-CALC-$protoCobolDataItem.cobolName$-SIZE
               SET W-STREAM TO ADDRESS OF W-P-VARINT
               COMPUTE W-Z-UINT32 =
                   W-$protoCobolDataItem.cobolName$-L
               PERFORM Z-UINT32-TO-P-VARINT THRU
                   END-Z-UINT32-TO-P-VARINT
               ADD W-BYTES-USED TO W-$parent.cobolName$-L
               ADD W-$protoCobolDataItem.cobolName$-L TO W-$parent.cobolName$-L

>>


debugParse(protoCobolDataItem) ::= <<
      D          DISPLAY '$protoCobolDataItem.indexedCobolName$ ='
      D                   $protoCobolDataItem.indexedCobolName$
      D                  ' ,AT OFFSET=' W-I
>>

debugWrite(protoCobolDataItem) ::= <<
      D        DISPLAY '$protoCobolDataItem.indexedCobolName$ ='
      D                 $protoCobolDataItem.indexedCobolName$
      D                ' ,AT OFFSET=' W-I
>>

incrementCounter(protoCobolDataItem) ::= <<
$if(protoCobolDataItem.array)$
                 ADD 1 TO $protoCobolDataItem.cobolCounterName$
$if(protoCobolDataItem.hasDependingOn)$
                 MOVE $protoCobolDataItem.cobolCounterName$ TO $protoCobolDataItem.dependingOn$$endif$$endif$
>>


